---
title: Java的内存模型JMM
date: 2022-05-18
tags: Java
---

# Java内存模型JMM

Java内存模型，Java Memory Model，是一种抽象的概念，它描述了一组规则或规范，通过这组规范定义了程序中各个变量的访问方式

**主内存、工作内存*：*

- 主内存：JVM的堆，共享的
- 工作内存：栈空间，线程私有的数据

## JMM中的主内存

- 存储Java实例对象
- 包括成员变量、类信息Class、常量Constant、静态变量Static
- 共享区域，JVM的堆，会引发线程安全问题

## JMM中的工作内存

- 当前线程私有的
- 字节码行号指示器，Native方法信息
- 属于线程私有数据区域，不存在线程安全问题

**JMM是一组规则，围绕原子性、有序性、可见性**

- 方法里的基本数据类型本地变量，直接存储再工作内存的栈帧结构中
- 引用类型的本地变量，存储在工作内存中，实例存储在主内存中
- 成员变量、static变量、类信息，存储在主内存中
- 主内存共享的方式，是线程拷贝一份数据到工作内存，操作完后再刷新回主内存

## volatile规则（happens-before原则之一）

- JVM提供的轻量级同步机制
- 堆同一个变量的写操作，先于读操作
- 修改完之后，其他线程立即知道（可见性），在主内存中存储的

## volatile 和 synchronized 的区别，总结

1. volatile的本质是，告诉JVM当前变量是不确定的，需要从主存中读取
2. synchronized则是锁定当前对象，只有当前线程可以操作该对象，其他线程要被阻塞
3. volatile仅能使用在变量级别，synchronized可以使用在变量、方法和类级别
4. volatile仅能实现变量的**可见性，不能保证原子性**（多线程同时操作一个对象，读，改，写回可能会出问题，因为在这过程中，被其他线程抢先改了）
5. synchronized可以保证变量修改的**可见性和原子性**
6. **volatile不会造成线程的阻塞，synchronized可能会造成线程的阻塞**（具体要看锁的类型，自旋、轻量、重量）
7. volatile标记的变量，不会被编译器优化，不会产生指令重排序的问题，synchronized标记的变量可以被编译器优化
