---
title: Java多线程（二）
date: 2022-05-17
tags: Java
---

# Java多线程与并发

## synchronized

**线程安全问题的原因**

- 存在共享数据（临界资源）
- 存在多条线程共同操作这些共享数据

**解决问题的根本方法：**

同一时刻有且只有一个线程在操作共享数据，其他线程必须等待到该线程处理完数据后再进行操作。

**互斥锁的特性**

- 互斥性：在同一个时间只允许一个线程拥有该对象锁
- 可见性：确保在锁释放之前，对共享变量所做的修改，对于随后获得锁的另外一个线程是可见的，否则另一个线程可能是在本地缓存的某个副本上继续操作，引发不一致问题。

**获取对像锁的两种用法**

- 同步代码块：synchronized(this), synchronized(类实例对象)，锁是小括号中的实例对象
- 同步非静态方法，synchronized method，锁是当前对象的实例对象

## synchoronized底层实现原理

- Java对象头
- Monitor

## 对象在内存中的布局

- 对象头
- 实例数据
- 对齐填充

## 对象锁的重入

某个已经持有对象锁的线程，试图再次请求对象锁，就叫做重入

## 自旋锁

- 许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得
- 通过让线程执行忙循环，等待锁的释放，不让出CPU
- 缺点：若锁被其他线程长时间占用，会带来许多性能上的开销

## 自适应自旋锁

- 自旋次数不再不定
- 由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定

## 锁消除（锁的优化，消除不必要的锁）

- JIT编译时，对运行上下文扫描，去除不可能存在竞争的锁
- 例如StringBuffer，在单个线程的block中本地变量操作时，不可能被其他线程访问，所以JVM会自动消除StringBuffer的锁

## 锁粗化

- 频繁的对同一个锁对象进行互斥操作，例如for循环while循环里，对StringBuffer对象进行操作，JVM会优化，减少不必要的加锁，解锁

## synchronized的四种状态

无锁、**偏向锁**、**轻量级锁**、重量级锁

## 偏向锁

**偏向锁：减少同一线程获取锁的代价**

- 大多数情况下，锁不存在多线程竞争，总是由同一条线程多次获得

- **核心思想：
如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word的结构也变成偏向锁结构，当该线程再次请求锁时，无需再做任何的同步操作，即获取锁的过程只需要检查Mark Word的锁标记位为偏向锁，以及当前线程Id等于Mark Word的ThreadID即可，这样可以省去大量有关锁申请的操作。**

## 轻量级锁（由偏向锁升级而来）

- 由第二个线程加入争用的时候，偏向锁会升级成轻量级锁
- 适应的场景：线程交替执行同步块

# ReentrantLock（再入锁，Java.utils里的更自由的锁，比synchronized更自由）

## ReentrantLock将锁对象化

- 判断是否由线程，或某个特性线程，在排队等待获取锁
- 带超时的获取锁的尝试
- 感知有没有成功获取锁

## ReentrantLock 与 synchronized 的区别

- synchronized是关键字，ReentrantLock是类
- ReentrantLock可以对锁的等待时间进行设置，避免死锁
- ReentrantLock可以获取锁的各种信息
- ReentrantLock可以灵活的实现多路通知
- sync操作的是对象头的Mark Word，lock调用的是Unsafe类的park方法

