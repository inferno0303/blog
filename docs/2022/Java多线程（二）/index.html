<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        小菠菜NVM
    </title>
    <link rel="shortcut icon" href="/favicon.ico">
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.2.0"></head>

<body>
    <header class="header">
    <div class="header-wrapper">
        <div class="blog-title">
            <a href="/" class="blog-title-link">
                小菠菜NVM
            </a>
        </div>
        <nav class="navbar">
            <div class="menu">
                
                    <div class="menu-item">
                        <a target="_blank" rel="noopener" href="https://github.com/inferno0303" class="menu-item-link">
                            关于
                        </a>
                    </div>
                    
            </div>
        </nav>
    </div>
</header>
    <div class="main">
        <article class="post-wrapper">
  <div class="post-title">
    <h1 class="title">Java多线程（二）</h1>
  </div>
  <div class="post-meta">
    <span class="post-time">2022-05-17</span>
  </div>
  <div class="post-content"><h1 id="Java多线程与并发"><a href="#Java多线程与并发" class="headerlink" title="Java多线程与并发"></a>Java多线程与并发</h1><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p><strong>线程安全问题的原因</strong></p>
<ul>
<li>存在共享数据（临界资源）</li>
<li>存在多条线程共同操作这些共享数据</li>
</ul>
<p><strong>解决问题的根本方法：</strong></p>
<p>同一时刻有且只有一个线程在操作共享数据，其他线程必须等待到该线程处理完数据后再进行操作。</p>
<p><strong>互斥锁的特性</strong></p>
<ul>
<li>互斥性：在同一个时间只允许一个线程拥有该对象锁</li>
<li>可见性：确保在锁释放之前，对共享变量所做的修改，对于随后获得锁的另外一个线程是可见的，否则另一个线程可能是在本地缓存的某个副本上继续操作，引发不一致问题。</li>
</ul>
<p><strong>获取对像锁的两种用法</strong></p>
<ul>
<li>同步代码块：synchronized(this), synchronized(类实例对象)，锁是小括号中的实例对象</li>
<li>同步非静态方法，synchronized method，锁是当前对象的实例对象</li>
</ul>
<h2 id="synchoronized底层实现原理"><a href="#synchoronized底层实现原理" class="headerlink" title="synchoronized底层实现原理"></a>synchoronized底层实现原理</h2><ul>
<li>Java对象头</li>
<li>Monitor</li>
</ul>
<h2 id="对象在内存中的布局"><a href="#对象在内存中的布局" class="headerlink" title="对象在内存中的布局"></a>对象在内存中的布局</h2><ul>
<li>对象头</li>
<li>实例数据</li>
<li>对齐填充</li>
</ul>
<h2 id="对象锁的重入"><a href="#对象锁的重入" class="headerlink" title="对象锁的重入"></a>对象锁的重入</h2><p>某个已经持有对象锁的线程，试图再次请求对象锁，就叫做重入</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><ul>
<li>许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得</li>
<li>通过让线程执行忙循环，等待锁的释放，不让出CPU</li>
<li>缺点：若锁被其他线程长时间占用，会带来许多性能上的开销</li>
</ul>
<h2 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h2><ul>
<li>自旋次数不再不定</li>
<li>由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定</li>
</ul>
<h2 id="锁消除（锁的优化，消除不必要的锁）"><a href="#锁消除（锁的优化，消除不必要的锁）" class="headerlink" title="锁消除（锁的优化，消除不必要的锁）"></a>锁消除（锁的优化，消除不必要的锁）</h2><ul>
<li>JIT编译时，对运行上下文扫描，去除不可能存在竞争的锁</li>
<li>例如StringBuffer，在单个线程的block中本地变量操作时，不可能被其他线程访问，所以JVM会自动消除StringBuffer的锁</li>
</ul>
<h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><ul>
<li>频繁的对同一个锁对象进行互斥操作，例如for循环while循环里，对StringBuffer对象进行操作，JVM会优化，减少不必要的加锁，解锁</li>
</ul>
<h2 id="synchronized的四种状态"><a href="#synchronized的四种状态" class="headerlink" title="synchronized的四种状态"></a>synchronized的四种状态</h2><p>无锁、<strong>偏向锁</strong>、<strong>轻量级锁</strong>、重量级锁</p>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p><strong>偏向锁：减少同一线程获取锁的代价</strong></p>
<ul>
<li><p>大多数情况下，锁不存在多线程竞争，总是由同一条线程多次获得</p>
</li>
<li><p><strong>核心思想：<br>如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word的结构也变成偏向锁结构，当该线程再次请求锁时，无需再做任何的同步操作，即获取锁的过程只需要检查Mark Word的锁标记位为偏向锁，以及当前线程Id等于Mark Word的ThreadID即可，这样可以省去大量有关锁申请的操作。</strong></p>
</li>
</ul>
<h2 id="轻量级锁（由偏向锁升级而来）"><a href="#轻量级锁（由偏向锁升级而来）" class="headerlink" title="轻量级锁（由偏向锁升级而来）"></a>轻量级锁（由偏向锁升级而来）</h2><ul>
<li>由第二个线程加入争用的时候，偏向锁会升级成轻量级锁</li>
<li>适应的场景：线程交替执行同步块</li>
</ul>
<h1 id="ReentrantLock（再入锁，Java-utils里的更自由的锁，比synchronized更自由）"><a href="#ReentrantLock（再入锁，Java-utils里的更自由的锁，比synchronized更自由）" class="headerlink" title="ReentrantLock（再入锁，Java.utils里的更自由的锁，比synchronized更自由）"></a>ReentrantLock（再入锁，Java.utils里的更自由的锁，比synchronized更自由）</h1><h2 id="ReentrantLock将锁对象化"><a href="#ReentrantLock将锁对象化" class="headerlink" title="ReentrantLock将锁对象化"></a>ReentrantLock将锁对象化</h2><ul>
<li>判断是否由线程，或某个特性线程，在排队等待获取锁</li>
<li>带超时的获取锁的尝试</li>
<li>感知有没有成功获取锁</li>
</ul>
<h2 id="ReentrantLock-与-synchronized-的区别"><a href="#ReentrantLock-与-synchronized-的区别" class="headerlink" title="ReentrantLock 与 synchronized 的区别"></a>ReentrantLock 与 synchronized 的区别</h2><ul>
<li>synchronized是关键字，ReentrantLock是类</li>
<li>ReentrantLock可以对锁的等待时间进行设置，避免死锁</li>
<li>ReentrantLock可以获取锁的各种信息</li>
<li>ReentrantLock可以灵活的实现多路通知</li>
<li>sync操作的是对象头的Mark Word，lock调用的是Unsafe类的park方法</li>
</ul>
</div>
</article>
    </div>
    <div class="footer">
    <p>
        © Copyright 2022 小菠菜
    </p>
    <p>
        Power By <a target="_blank" rel="noopener" href="https://hexo.io/" style="text-decoration: none">Hexo</a>
    </p>
</div>
</body>

</html>