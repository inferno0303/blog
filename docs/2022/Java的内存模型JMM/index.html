<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        小菠菜NVM
    </title>
    <link rel="shortcut icon" href="/favicon.ico">
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.2.0"></head>

<body>
    <header class="header">
    <div class="header-wrapper">
        <div class="blog-title">
            <a href="/" class="blog-title-link">
                小菠菜NVM
            </a>
        </div>
        <nav class="navbar">
            <div class="menu">
                
                    <div class="menu-item">
                        <a href="/archives" class="menu-item-link">
                            归档
                        </a>
                    </div>
                    
                    <div class="menu-item">
                        <a href="/tags" class="menu-item-link">
                            标签
                        </a>
                    </div>
                    
                    <div class="menu-item">
                        <a target="_blank" rel="noopener" href="https://github.com/inferno0303" class="menu-item-link">
                            GitHub
                        </a>
                    </div>
                    
            </div>
        </nav>
    </div>
</header>
    <div class="main">
        <article class="post-wrapper">
  <div class="post-title">
    <h1 class="h1-title">Java的内存模型JMM）</h1>
  </div>
  <div class="post-meta">
    <span class="post-tags">
      标签：
      
        <span class="tag">
          note 
        </span>
       
    </span>
    <span class="post-time">发布日期：2022-05-16</span>
  </div>
  <div class="post-content"><h1 id="Java内存模型JMM"><a href="#Java内存模型JMM" class="headerlink" title="Java内存模型JMM"></a>Java内存模型JMM</h1><p>Java内存模型，Java Memory Model，是一种抽象的概念，它描述了一组规则或规范，通过这组规范定义了程序中各个变量的访问方式</p>
<p>*<em>主内存、工作内存</em>：*</p>
<ul>
<li>主内存：JVM的堆，共享的</li>
<li>工作内存：栈空间，线程私有的数据</li>
</ul>
<h2 id="JMM中的主内存"><a href="#JMM中的主内存" class="headerlink" title="JMM中的主内存"></a>JMM中的主内存</h2><ul>
<li>存储Java实例对象</li>
<li>包括成员变量、类信息Class、常量Constant、静态变量Static</li>
<li>共享区域，JVM的堆，会引发线程安全问题</li>
</ul>
<h2 id="JMM中的工作内存"><a href="#JMM中的工作内存" class="headerlink" title="JMM中的工作内存"></a>JMM中的工作内存</h2><ul>
<li>当前线程私有的</li>
<li>字节码行号指示器，Native方法信息</li>
<li>属于线程私有数据区域，不存在线程安全问题</li>
</ul>
<p><strong>JMM是一组规则，围绕原子性、有序性、可见性</strong></p>
<ul>
<li>方法里的基本数据类型本地变量，直接存储再工作内存的栈帧结构中</li>
<li>引用类型的本地变量，存储在工作内存中，实例存储在主内存中</li>
<li>成员变量、static变量、类信息，存储在主内存中</li>
<li>主内存共享的方式，是线程拷贝一份数据到工作内存，操作完后再刷新回主内存</li>
</ul>
<h2 id="volatile规则（happens-before原则之一）"><a href="#volatile规则（happens-before原则之一）" class="headerlink" title="volatile规则（happens-before原则之一）"></a>volatile规则（happens-before原则之一）</h2><ul>
<li>JVM提供的轻量级同步机制</li>
<li>堆同一个变量的写操作，先于读操作</li>
<li>修改完之后，其他线程立即知道（可见性），在主内存中存储的</li>
</ul>
<h2 id="volatile-和-synchronized-的区别，总结"><a href="#volatile-和-synchronized-的区别，总结" class="headerlink" title="volatile 和 synchronized 的区别，总结"></a>volatile 和 synchronized 的区别，总结</h2><ol>
<li>volatile的本质是，告诉JVM当前变量是不确定的，需要从主存中读取</li>
<li>synchronized则是锁定当前对象，只有当前线程可以操作该对象，其他线程要被阻塞</li>
<li>volatile仅能使用在变量级别，synchronized可以使用在变量、方法和类级别</li>
<li>volatile仅能实现变量的<strong>可见性，不能保证原子性</strong>（多线程同时操作一个对象，读，改，写回可能会出问题，因为在这过程中，被其他线程抢先改了）</li>
<li>synchronized可以保证变量修改的<strong>可见性和原子性</strong></li>
<li><strong>volatile不会造成线程的阻塞，synchronized可能会造成线程的阻塞</strong>（具体要看锁的类型，自旋、轻量、重量）</li>
<li>volatile标记的变量，不会被编译器优化，不会产生指令重排序的问题，synchronized标记的变量可以被编译器优化</li>
</ol>
</div>
</article>
    </div>
    <div class="footer">
    <p>
        © Copyright 2022 <a target="_blank" rel="noopener" href="https://github.com/inferno0303/" style="text-decoration: none">inferno0303</a>
    </p>
    <p>
        Power By <a target="_blank" rel="noopener" href="https://hexo.io/" style="text-decoration: none">Hexo</a>
    </p>
</div>
</body>

</html>