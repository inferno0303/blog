<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        心流-flow
    </title>
    <link rel="shortcut icon" href="/favicon.ico">
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/hljs-default-min.css">
 
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
    <header class="header">
    <div class="header-wrapper">
        <div class="blog-title">
            <a href="/" class="blog-title-link">
                心流-flow
            </a>
        </div>
        <nav class="menu">
            
                <li class="menu-item">
                    <a href="/">
                        首页
                    </a>
                </li>
            
                <li class="menu-item">
                    <a href="/archives">
                        归档
                    </a>
                </li>
            
                <li class="menu-item">
                    <a href="/tags">
                        标签
                    </a>
                </li>
            
                <li class="menu-item">
                    <a target="_blank" rel="noopener" href="https://github.com/inferno0303">
                        关于
                    </a>
                </li>
            
        </nav>
    </div>
</header>
    <div class="main">
        <article class="post-wrapper">
  <div class="post-title" id="post-title">
    <h1 class="h1-title">
      Java多线程（一）
    </h1>
  </div>
  <div class="post-meta">
    <span class="post-tags">
      
        <a href="/tags/Java">#Java</a>
        
        <a href="/tags/note">#note</a>
        
    </span>
    <span class="post-word-count">10084字</span>
    <span class="post-time">2022-05-16</span>
  </div>
  <div class="post-content">
    <h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h1><h2 id="1、进程和线程的联系"><a href="#1、进程和线程的联系" class="headerlink" title="1、进程和线程的联系"></a>1、进程和线程的联系</h2><h3 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h3><p>串行：初期计算机只能串行执行任务，并且需要长时间等待用户输入</p>
<p>批处理：预先将用户的指令集中成清单，批量串行处理用户指令，仍然无法并发执行</p>
<p>进程：进程独占内存空间，保存各自运行状态，相互间不干扰且可以互相切换，为并发处理任务提供了可能</p>
<p>线程：共享进程的内存资源，相互间切换更快速，支持更细粒度的任务控制，使进程内的子任务得以并发执行</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><strong>一句话总结：进程是资源分配的最小单位，线程是CPU调度的最小单位。</strong></p>
<ul>
<li>所有与进程相关的资源，都被记录在PCB中</li>
<li>进程是抢占处理机的调度单位；线程属于某个线程，共享其资源</li>
<li>进程拥有虚拟地址空间，线程属于进程，共享虚拟地址空间</li>
<li>线程只由堆栈寄存器、程序计数器和TCB组成</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>线程不能看作独立应用，进程可以看作独立应用</li>
<li>进程拥有独立的地址空间，相互不影响，线程只是进程的不同执行路径</li>
<li>线程没有独立的地址空间，多进程的程序比多线程程序健壮</li>
<li>进程的切换比线程的切换开销大</li>
</ul>
<h3 id="JVM的进程和线程"><a href="#JVM的进程和线程" class="headerlink" title="JVM的进程和线程"></a>JVM的进程和线程</h3><ul>
<li>Java对操作系统提供的功能进行封装，包括进程和线程</li>
<li>运行一个程序会产生一个进程，进程包含至少一个线程</li>
<li>每个进程对应一个JVM实例，多个线程共享JVM堆内存</li>
<li>Java采用单线程编程模型，程序会自动创建主线程</li>
<li>主线程可以创建子线程，原则上要后于子线程完成执行</li>
</ul>
<h2 id="2、示例：打印当前线程名"><a href="#2、示例：打印当前线程名" class="headerlink" title="2、示例：打印当前线程名"></a>2、示例：打印当前线程名</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CurrentThread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> thread.getName();<br>        System.out.println(name); <span class="hljs-comment">// -&gt; main</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>JVM是多线程的，在启动的时候，会启动其他线程，比如垃圾收集器GC线程。</strong></p>
<h2 id="3、线程的生命周期"><a href="#3、线程的生命周期" class="headerlink" title="3、线程的生命周期"></a>3、线程的生命周期</h2><p>新建状态 -&gt; 就绪状态 -&gt; 运行状态 -&gt; 阻塞状态 -&gt; 死亡状态</p>
<ul>
<li>新建状态：使用new关键字和Thread类或子类建立一个线程对象后，线程处于新建状态。</li>
<li>就绪状态：线程调用了start()方法后，进入就绪状态，处于就绪队列中，要等待JVM线程调度器的调度。</li>
<li>运行状态：获取CPU资源，执行run()方法，它可以变为阻塞状态，就绪状态，或死亡状态。</li>
<li>阻塞状态：如果一个线程执行了sleep睡眠、suspend挂起等方法，失去所占用的资源后，该线程就从运行状态进入阻塞状态，在睡眠时间结束，或重新获得设备资源后，科重新进入就绪状态，可以分为三种：</li>
<li><ul>
<li>等待阻塞：运行中执行wait()，线程进入等待阻塞状态</li>
</ul>
</li>
<li><ul>
<li>同步阻塞，线程获取synchronizes同步锁失败（因为同步锁被其他线程占用）</li>
</ul>
</li>
<li><ul>
<li>其他阻塞：通过调用线程的sleep()或join()发出了I&#x2F;O请求，线程就进入阻塞状态，当sleep结束，或join等待线程终止或超时，或I&#x2F;O处理完毕，线程重新进入就绪态</li>
</ul>
</li>
<li>死亡状态：一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态</li>
</ul>
<h3 id="Java线程的状态，6个状态"><a href="#Java线程的状态，6个状态" class="headerlink" title="Java线程的状态，6个状态"></a>Java线程的状态，6个状态</h3><ul>
<li>新建（new）：创建后尚未启动的状态</li>
<li>运行（Runnable）：调用了start方法后，包含Running和Ready，Ready状态是在线程池中，还没有轮到，Running是正在执行</li>
<li>无限等待（Waiting）：不会被分配CPU执行时间，需要被显式的唤醒wait方法，join方法</li>
<li>限期等待（Timed Waiting）：在一定时间后会被系统自动唤醒</li>
<li>阻塞（Blocked）：等待获取排他锁</li>
<li>结束（Terminated）：已终止线程的状态，线程已经结束运行</li>
</ul>
<h2 id="4、线程的优先级"><a href="#4、线程的优先级" class="headerlink" title="4、线程的优先级"></a>4、线程的优先级</h2><p>每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。<br>Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。<br>默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。<br>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台.</p>
<h2 id="5、创建一个Java线程"><a href="#5、创建一个Java线程" class="headerlink" title="5、创建一个Java线程"></a>5、创建一个Java线程</h2><ul>
<li>通过实现Runnable接口</li>
<li>通过继承Thread类本身（实现了Runnable接口）</li>
<li>通过Callable和Future创建线程（有返回值）</li>
</ul>
<h3 id="通过Runable接口创建线程"><a href="#通过Runable接口创建线程" class="headerlink" title="通过Runable接口创建线程"></a>通过Runable接口创建线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Thread t;<br>    <span class="hljs-keyword">private</span> String threadName;<br><br>    RunnableDemo(String name) &#123;<br>        <span class="hljs-built_in">this</span>.threadName = name;<br>        System.out.println(<span class="hljs-string">&quot;创建了线程：&quot;</span> + threadName);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;正在运行线程：&quot;</span> + <span class="hljs-built_in">this</span>.threadName);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>                System.out.println(<span class="hljs-built_in">this</span>.threadName + <span class="hljs-string">&quot;正在执行run()方法&quot;</span> + i);<br>                Thread.sleep(<span class="hljs-number">50</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>        System.out.println(<span class="hljs-built_in">this</span>.threadName + <span class="hljs-string">&quot;执行run()方法完成了，退出&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;开始&quot;</span> + <span class="hljs-built_in">this</span>.threadName);<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123;<br>            t = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-built_in">this</span>, threadName); <span class="hljs-comment">// 利用new Thread()实例化一个Thread对象，把实现Runnable接口的类传进去</span><br>            t.start(); <span class="hljs-comment">// 调用Thread类的start()方法，创建一个线程，线程会进入就绪状态，获取资源后，JVM会自动调用该线程run()方法进入执行态</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// main线程调用其他线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestThread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">RunnableDemo</span> <span class="hljs-variable">R1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableDemo</span>(<span class="hljs-string">&quot;线程1&quot;</span>);<br>        R1.start();<br>        <span class="hljs-type">RunnableDemo</span> <span class="hljs-variable">R2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableDemo</span>(<span class="hljs-string">&quot;线程2&quot;</span>);<br>        R2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">创建了线程：线程1<br>开始线程1<br>创建了线程：线程2<br>开始线程2<br>正在运行线程：线程1<br>正在运行线程：线程2<br>线程2正在执行run()方法4<br>线程1正在执行run()方法4<br>线程2正在执行run()方法3<br>线程1正在执行run()方法3<br>线程2正在执行run()方法2<br>线程1正在执行run()方法2<br>线程2正在执行run()方法1<br>线程1正在执行run()方法1<br>线程2执行run()方法完成了，退出<br>线程1执行run()方法完成了，退出<br></code></pre></td></tr></table></figure>

<h3 id="通过继承Thread类来创建线程"><a href="#通过继承Thread类来创建线程" class="headerlink" title="通过继承Thread类来创建线程"></a>通过继承Thread类来创建线程</h3><p><strong>本质上也是重写run方法，毕竟Thread类也是实现Runnable接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> Thread t;<br>    <span class="hljs-keyword">private</span> String threadName;<br><br>    ThreadDemo(String name) &#123;<br>        <span class="hljs-built_in">this</span>.threadName = name;<br>        System.out.println(<span class="hljs-string">&quot;创建了线程：&quot;</span> + threadName);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;正在运行线程：&quot;</span> + <span class="hljs-built_in">this</span>.threadName);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>                System.out.println(<span class="hljs-built_in">this</span>.threadName + <span class="hljs-string">&quot;正在执行run()方法&quot;</span> + i);<br>                Thread.sleep(<span class="hljs-number">50</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>        System.out.println(<span class="hljs-built_in">this</span>.threadName + <span class="hljs-string">&quot;执行run()方法完成了，退出&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;开始&quot;</span> + <span class="hljs-built_in">this</span>.threadName);<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123;<br>            t = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-built_in">this</span>, threadName);<br>            t.start();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestThread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadDemo</span> <span class="hljs-variable">T1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadDemo</span>(<span class="hljs-string">&quot;线程-1&quot;</span>);<br>        T1.start();<br>        <span class="hljs-type">ThreadDemo</span> <span class="hljs-variable">T2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadDemo</span>(<span class="hljs-string">&quot;线程-2&quot;</span>);<br>        T2.start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="如何给run-方法传参"><a href="#如何给run-方法传参" class="headerlink" title="如何给run()方法传参"></a>如何给run()方法传参</h3><ul>
<li>构造函数传参</li>
<li>成员变量传参</li>
<li>回调函数传参</li>
</ul>
<h2 id="6、如何实现处理线程的返回值"><a href="#6、如何实现处理线程的返回值" class="headerlink" title="6、如何实现处理线程的返回值"></a>6、如何实现处理线程的返回值</h2><ul>
<li>主线程等待法</li>
<li>使用Thread类的join()阻塞当前线程以等待子线程处理完毕</li>
<li>通过Callable接口实现，通过FutureTask或线程池Future获取</li>
</ul>
<p>(1) 主线程等待法示例（很蠢）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CycleWait</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-built_in">this</span>.value = <span class="hljs-string">&quot;we hava data now!&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">CycleWait</span> <span class="hljs-variable">cw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CycleWait</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(cw);<br>        thread.start();<br>        <span class="hljs-comment">// 主线程等待法，基于子线程类成员变量，等待子线程值</span><br>        System.out.println(<span class="hljs-string">&quot;waiting for value ...&quot;</span>);<br>        <span class="hljs-keyword">while</span> (cw.value == <span class="hljs-literal">null</span>) &#123;<br>            Thread.sleep(<span class="hljs-number">100</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;value: &quot;</span> + cw.value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>(2) 阻塞当前线程，等待子线程执行完成，（join方法阻塞当前线程）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">CycleWait</span> <span class="hljs-variable">cw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CycleWait</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(cw);<br>        thread.start();<br>        <span class="hljs-comment">// 线程实例.join()方法，阻塞当前的main线程，等待run()执行完成</span><br>        System.out.println(<span class="hljs-string">&quot;waiting for value ...&quot;</span>);<br>        thread.join();<br>        System.out.println(<span class="hljs-string">&quot;value: &quot;</span> + cw.value);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>(3) 结合Callable接口和FutureTask类获取run方法返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<br><span class="hljs-keyword">import</span> java.util.concurrent.FutureTask;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;start task&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            total += i;<br>        &#125;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        System.out.println(<span class="hljs-string">&quot;task done&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;The total is: &quot;</span> + total;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        FutureTask&lt;String&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>());<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task);<br>        thread.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> task.get(); <span class="hljs-comment">// 等待有返回值后再执行</span><br>            System.out.println(<span class="hljs-string">&quot;sub thread return a value -&gt; \n&quot;</span> + s);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>(3.1) 基于线程池Future接口，本质上FutureTask也是实现了Future接口的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.Future;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">newCachedThreadPool</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br>        Future&lt;String&gt; future = newCachedThreadPool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>());<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(future.get());<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 不要忘记关闭线程池</span><br>            newCachedThreadPool.shutdown();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="7、sleep和wait的区别"><a href="#7、sleep和wait的区别" class="headerlink" title="7、sleep和wait的区别"></a>7、sleep和wait的区别</h2><p><strong>最本质的区别</strong></p>
<ul>
<li>Thread.sleep 只会让出CPU，不会导致锁的改变</li>
<li>Object.wait 不仅会让出CPU，还会释放已经占有的同步资源锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitSleepDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <br>        <span class="hljs-comment">// 锁</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello world!&quot;</span>;<br>        <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Thread 1 is waiting to get lock...&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        System.out.println(<span class="hljs-string">&quot;Thread 1 get lock: &quot;</span> + lock);<br>                        lock.wait(<span class="hljs-number">1000</span>); <span class="hljs-comment">// wait会释放锁</span><br>                        System.out.println(<span class="hljs-string">&quot;Thread 1 is done&quot;</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Thread 2 is waiting to get lock...&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        System.out.println(<span class="hljs-string">&quot;Thread 2 get lock: &quot;</span> + lock);<br>                        Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// sleep不会释放锁资源</span><br>                        System.out.println(<span class="hljs-string">&quot;Thread 2 is done&quot;</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Thread 1 is waiting to get lock...<br>Thread 1 get lock: hello world!<br>Thread 2 is waiting to get lock...<br>Thread 2 get lock: hello world!<br>Thread 2 is done<br>Thread 1 is done<br></code></pre></td></tr></table></figure>

<h2 id="8、notify和notifyAll的区别"><a href="#8、notify和notifyAll的区别" class="headerlink" title="8、notify和notifyAll的区别"></a>8、notify和notifyAll的区别</h2><p>某个对象，关于锁，对象有以下两个池：</p>
<ul>
<li>锁池EntryList</li>
<li>等待池WaitSet</li>
</ul>
<h3 id="锁池（排队，竞争锁的拥有权）"><a href="#锁池（排队，竞争锁的拥有权）" class="headerlink" title="锁池（排队，竞争锁的拥有权）"></a>锁池（排队，竞争锁的拥有权）</h3><p>假设线程A已经拥有了某个对象的锁，而其他线程B、C想要调用这个对象的某个synchronized方法，由于B、C线程在进入对象的synchronized方法（或者块）之前必须获得该对象锁的拥有权，恰巧该对象的锁目前正在被线程A占用，此时B、C线程就会被阻塞，进入一个地方去等待锁的释放，这个地方便是该对象的锁池</p>
<h3 id="等待池（不参与竞争锁的拥有权，等notify，或wait时间到）"><a href="#等待池（不参与竞争锁的拥有权，等notify，或wait时间到）" class="headerlink" title="等待池（不参与竞争锁的拥有权，等notify，或wait时间到）"></a>等待池（不参与竞争锁的拥有权，等notify，或wait时间到）</h3><p>假设线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁，同时线程A就进入到了该对象的等待池中，进入到等待池中的线程不会去竞争该对象的锁</p>
<ul>
<li>notifyAll会让所有处于等待池的线程全部进入锁池中，去竞争</li>
<li>notify只会随机选取一个处于等待池中的线程，进入到锁池中，去竞争</li>
</ul>
<h2 id="9、如何中断线程"><a href="#9、如何中断线程" class="headerlink" title="9、如何中断线程"></a>9、如何中断线程</h2><h3 id="已经被抛弃的方法"><a href="#已经被抛弃的方法" class="headerlink" title="已经被抛弃的方法"></a>已经被抛弃的方法</h3><ul>
<li>stop方法</li>
<li>suspend和resume方法</li>
</ul>
<h3 id="目前使用的方法"><a href="#目前使用的方法" class="headerlink" title="目前使用的方法"></a>目前使用的方法</h3><ul>
<li>interrupt方法，通知线程应该要中断了<br>-&gt; 如果线程处于被阻塞的状态，那么线程将立即退出被阻塞的状态，并抛出一个InterruptedException异常<br>-&gt; 如果线程处于正常的活动状态，那么会将该线程的中断标志设置为true，被设置中断标志的线程会正常运行，需要手动处理</li>
</ul>
<p>要经常检查中断标志位</p>
<h2 id="10、yield暗示可以让出当前线程的CPU资源"><a href="#10、yield暗示可以让出当前线程的CPU资源" class="headerlink" title="10、yield暗示可以让出当前线程的CPU资源"></a>10、yield暗示可以让出当前线程的CPU资源</h2><p>不会对锁造成影响，调度器可能会忽略，不一定每次都一样</p>

  </div>
</article>
<script>
  let title = document.getElementById("post-title").getElementsByClassName("h1-title");
  if (title.length > 0) {
    document.title = title[0].innerText;
  }
</script>
    </div>
    <div class="footer">
    <p>
        © Copyright 2022 <a target="_blank" rel="noopener" href="https://github.com/inferno0303/" style="color: #ccc;">inferno0303</a>
    </p>
</div>
</body>

</html>