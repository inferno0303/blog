<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        小菠菜NVM
    </title>
    <link rel="shortcut icon" href="/favicon.ico">
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.2.0"></head>

<body>
    <header class="header">
    <div class="header-wrapper">
        <div class="blog-title">
            <a href="/" class="blog-title-link">
                小菠菜NVM
            </a>
        </div>
        <nav class="navbar">
            <div class="menu">
                
                    <div class="menu-item">
                        <a href="/" class="menu-item-link">
                            首页
                        </a>
                    </div>
                    
                    <div class="menu-item">
                        <a href="/archives" class="menu-item-link">
                            归档
                        </a>
                    </div>
                    
                    <div class="menu-item">
                        <a href="/tags" class="menu-item-link">
                            标签
                        </a>
                    </div>
                    
                    <div class="menu-item">
                        <a target="_blank" rel="noopener" href="https://github.com/inferno0303" class="menu-item-link">
                            关于
                        </a>
                    </div>
                    
            </div>
        </nav>
    </div>
</header>
    <div class="main">
        <article class="post-wrapper">
  <div class="post-title">
    <h1 class="h1-title">
      Java多线程（一）
    </h1>
  </div>
  <div class="post-meta">
    <span class="post-tags">
      
        <a href="/tags/note">#note</a>
        
    </span>
    <span class="post-time">2022-05-16</span>
  </div>
  <div class="post-content">
    <h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h1><h2 id="1、进程和线程的联系"><a href="#1、进程和线程的联系" class="headerlink" title="1、进程和线程的联系"></a>1、进程和线程的联系</h2><h3 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h3><p>串行：初期计算机只能串行执行任务，并且需要长时间等待用户输入</p>
<p>批处理：预先将用户的指令集中成清单，批量串行处理用户指令，仍然无法并发执行</p>
<p>进程：进程独占内存空间，保存各自运行状态，相互间不干扰且可以互相切换，为并发处理任务提供了可能</p>
<p>线程：共享进程的内存资源，相互间切换更快速，支持更细粒度的任务控制，使进程内的子任务得以并发执行</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><strong>一句话总结：进程是资源分配的最小单位，线程是CPU调度的最小单位。</strong></p>
<ul>
<li>所有与进程相关的资源，都被记录在PCB中</li>
<li>进程是抢占处理机的调度单位；线程属于某个线程，共享其资源</li>
<li>进程拥有虚拟地址空间，线程属于进程，共享虚拟地址空间</li>
<li>线程只由堆栈寄存器、程序计数器和TCB组成</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>线程不能看作独立应用，进程可以看作独立应用</li>
<li>进程拥有独立的地址空间，相互不影响，线程只是进程的不同执行路径</li>
<li>线程没有独立的地址空间，多进程的程序比多线程程序健壮</li>
<li>进程的切换比线程的切换开销大</li>
</ul>
<h3 id="JVM的进程和线程"><a href="#JVM的进程和线程" class="headerlink" title="JVM的进程和线程"></a>JVM的进程和线程</h3><ul>
<li>Java对操作系统提供的功能进行封装，包括进程和线程</li>
<li>运行一个程序会产生一个进程，进程包含至少一个线程</li>
<li>每个进程对应一个JVM实例，多个线程共享JVM堆内存</li>
<li>Java采用单线程编程模型，程序会自动创建主线程</li>
<li>主线程可以创建子线程，原则上要后于子线程完成执行</li>
</ul>
<h2 id="2、示例：打印当前线程名"><a href="#2、示例：打印当前线程名" class="headerlink" title="2、示例：打印当前线程名"></a>2、示例：打印当前线程名</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CurrentThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> thread.getName();</span><br><span class="line">        System.out.println(name); <span class="comment">// -&gt; main</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JVM是多线程的，在启动的时候，会启动其他线程，比如垃圾收集器GC线程。</strong></p>
<h2 id="3、线程的生命周期"><a href="#3、线程的生命周期" class="headerlink" title="3、线程的生命周期"></a>3、线程的生命周期</h2><p>新建状态 -&gt; 就绪状态 -&gt; 运行状态 -&gt; 阻塞状态 -&gt; 死亡状态</p>
<ul>
<li>新建状态：使用new关键字和Thread类或子类建立一个线程对象后，线程处于新建状态。</li>
<li>就绪状态：线程调用了start()方法后，进入就绪状态，处于就绪队列中，要等待JVM线程调度器的调度。</li>
<li>运行状态：获取CPU资源，执行run()方法，它可以变为阻塞状态，就绪状态，或死亡状态。</li>
<li>阻塞状态：如果一个线程执行了sleep睡眠、suspend挂起等方法，失去所占用的资源后，该线程就从运行状态进入阻塞状态，在睡眠时间结束，或重新获得设备资源后，科重新进入就绪状态，可以分为三种：</li>
<li><ul>
<li>等待阻塞：运行中执行wait()，线程进入等待阻塞状态</li>
</ul>
</li>
<li><ul>
<li>同步阻塞，线程获取synchronizes同步锁失败（因为同步锁被其他线程占用）</li>
</ul>
</li>
<li><ul>
<li>其他阻塞：通过调用线程的sleep()或join()发出了I&#x2F;O请求，线程就进入阻塞状态，当sleep结束，或join等待线程终止或超时，或I&#x2F;O处理完毕，线程重新进入就绪态</li>
</ul>
</li>
<li>死亡状态：一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态</li>
</ul>
<h3 id="Java线程的状态，6个状态"><a href="#Java线程的状态，6个状态" class="headerlink" title="Java线程的状态，6个状态"></a>Java线程的状态，6个状态</h3><ul>
<li>新建（new）：创建后尚未启动的状态</li>
<li>运行（Runnable）：调用了start方法后，包含Running和Ready，Ready状态是在线程池中，还没有轮到，Running是正在执行</li>
<li>无限等待（Waiting）：不会被分配CPU执行时间，需要被显式的唤醒wait方法，join方法</li>
<li>限期等待（Timed Waiting）：在一定时间后会被系统自动唤醒</li>
<li>阻塞（Blocked）：等待获取排他锁</li>
<li>结束（Terminated）：已终止线程的状态，线程已经结束运行</li>
</ul>
<h2 id="4、线程的优先级"><a href="#4、线程的优先级" class="headerlink" title="4、线程的优先级"></a>4、线程的优先级</h2><p>每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。<br>Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。<br>默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。<br>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台.</p>
<h2 id="5、创建一个Java线程"><a href="#5、创建一个Java线程" class="headerlink" title="5、创建一个Java线程"></a>5、创建一个Java线程</h2><ul>
<li>通过实现Runnable接口</li>
<li>通过继承Thread类本身（实现了Runnable接口）</li>
<li>通过Callable和Future创建线程（有返回值）</li>
</ul>
<h3 id="通过Runable接口创建线程"><a href="#通过Runable接口创建线程" class="headerlink" title="通过Runable接口创建线程"></a>通过Runable接口创建线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Thread t;</span><br><span class="line">    <span class="keyword">private</span> String threadName;</span><br><span class="line"></span><br><span class="line">    RunnableDemo(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.threadName = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建了线程：&quot;</span> + threadName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在运行线程：&quot;</span> + <span class="built_in">this</span>.threadName);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                System.out.println(<span class="built_in">this</span>.threadName + <span class="string">&quot;正在执行run()方法&quot;</span> + i);</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.threadName + <span class="string">&quot;执行run()方法完成了，退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始&quot;</span> + <span class="built_in">this</span>.threadName);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">            t = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>, threadName); <span class="comment">// 利用new Thread()实例化一个Thread对象，把实现Runnable接口的类传进去</span></span><br><span class="line">            t.start(); <span class="comment">// 调用Thread类的start()方法，创建一个线程，线程会进入就绪状态，获取资源后，JVM会自动调用该线程run()方法进入执行态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main线程调用其他线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RunnableDemo</span> <span class="variable">R1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableDemo</span>(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        R1.start();</span><br><span class="line">        <span class="type">RunnableDemo</span> <span class="variable">R2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableDemo</span>(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        R2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">创建了线程：线程1</span><br><span class="line">开始线程1</span><br><span class="line">创建了线程：线程2</span><br><span class="line">开始线程2</span><br><span class="line">正在运行线程：线程1</span><br><span class="line">正在运行线程：线程2</span><br><span class="line">线程2正在执行run()方法4</span><br><span class="line">线程1正在执行run()方法4</span><br><span class="line">线程2正在执行run()方法3</span><br><span class="line">线程1正在执行run()方法3</span><br><span class="line">线程2正在执行run()方法2</span><br><span class="line">线程1正在执行run()方法2</span><br><span class="line">线程2正在执行run()方法1</span><br><span class="line">线程1正在执行run()方法1</span><br><span class="line">线程2执行run()方法完成了，退出</span><br><span class="line">线程1执行run()方法完成了，退出</span><br></pre></td></tr></table></figure>

<h3 id="通过继承Thread类来创建线程"><a href="#通过继承Thread类来创建线程" class="headerlink" title="通过继承Thread类来创建线程"></a>通过继承Thread类来创建线程</h3><p><strong>本质上也是重写run方法，毕竟Thread类也是实现Runnable接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Thread t;</span><br><span class="line">    <span class="keyword">private</span> String threadName;</span><br><span class="line"></span><br><span class="line">    ThreadDemo(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.threadName = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建了线程：&quot;</span> + threadName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在运行线程：&quot;</span> + <span class="built_in">this</span>.threadName);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                System.out.println(<span class="built_in">this</span>.threadName + <span class="string">&quot;正在执行run()方法&quot;</span> + i);</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.threadName + <span class="string">&quot;执行run()方法完成了，退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始&quot;</span> + <span class="built_in">this</span>.threadName);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">            t = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>, threadName);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadDemo</span> <span class="variable">T1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadDemo</span>(<span class="string">&quot;线程-1&quot;</span>);</span><br><span class="line">        T1.start();</span><br><span class="line">        <span class="type">ThreadDemo</span> <span class="variable">T2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadDemo</span>(<span class="string">&quot;线程-2&quot;</span>);</span><br><span class="line">        T2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="如何给run-方法传参"><a href="#如何给run-方法传参" class="headerlink" title="如何给run()方法传参"></a>如何给run()方法传参</h3><ul>
<li>构造函数传参</li>
<li>成员变量传参</li>
<li>回调函数传参</li>
</ul>
<h2 id="6、如何实现处理线程的返回值"><a href="#6、如何实现处理线程的返回值" class="headerlink" title="6、如何实现处理线程的返回值"></a>6、如何实现处理线程的返回值</h2><ul>
<li>主线程等待法</li>
<li>使用Thread类的join()阻塞当前线程以等待子线程处理完毕</li>
<li>通过Callable接口实现，通过FutureTask或线程池Future获取</li>
</ul>
<p>(1) 主线程等待法示例（很蠢）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CycleWait</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.value = <span class="string">&quot;we hava data now!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CycleWait</span> <span class="variable">cw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CycleWait</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(cw);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// 主线程等待法，基于子线程类成员变量，等待子线程值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;waiting for value ...&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (cw.value == <span class="literal">null</span>) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;value: &quot;</span> + cw.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2) 阻塞当前线程，等待子线程执行完成，（join方法阻塞当前线程）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CycleWait</span> <span class="variable">cw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CycleWait</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(cw);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// 线程实例.join()方法，阻塞当前的main线程，等待run()执行完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;waiting for value ...&quot;</span>);</span><br><span class="line">        thread.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;value: &quot;</span> + cw.value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>(3) 结合Callable接口和FutureTask类获取run方法返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start task&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            total += i;</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;task done&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;The total is: &quot;</span> + total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        FutureTask&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> task.get(); <span class="comment">// 等待有返回值后再执行</span></span><br><span class="line">            System.out.println(<span class="string">&quot;sub thread return a value -&gt; \n&quot;</span> + s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3.1) 基于线程池Future接口，本质上FutureTask也是实现了Future接口的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">newCachedThreadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        Future&lt;String&gt; future = newCachedThreadPool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 不要忘记关闭线程池</span></span><br><span class="line">            newCachedThreadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7、sleep和wait的区别"><a href="#7、sleep和wait的区别" class="headerlink" title="7、sleep和wait的区别"></a>7、sleep和wait的区别</h2><p><strong>最本质的区别</strong></p>
<ul>
<li>Thread.sleep 只会让出CPU，不会导致锁的改变</li>
<li>Object.wait 不仅会让出CPU，还会释放已经占有的同步资源锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitSleepDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 锁</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 1 is waiting to get lock...&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Thread 1 get lock: &quot;</span> + lock);</span><br><span class="line">                        lock.wait(<span class="number">1000</span>); <span class="comment">// wait会释放锁</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;Thread 1 is done&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 2 is waiting to get lock...&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Thread 2 get lock: &quot;</span> + lock);</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>); <span class="comment">// sleep不会释放锁资源</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;Thread 2 is done&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread 1 is waiting to get lock...</span><br><span class="line">Thread 1 get lock: hello world!</span><br><span class="line">Thread 2 is waiting to get lock...</span><br><span class="line">Thread 2 get lock: hello world!</span><br><span class="line">Thread 2 is done</span><br><span class="line">Thread 1 is done</span><br></pre></td></tr></table></figure>

<h2 id="8、notify和notifyAll的区别"><a href="#8、notify和notifyAll的区别" class="headerlink" title="8、notify和notifyAll的区别"></a>8、notify和notifyAll的区别</h2><p>某个对象，关于锁，对象有以下两个池：</p>
<ul>
<li>锁池EntryList</li>
<li>等待池WaitSet</li>
</ul>
<h3 id="锁池（排队，竞争锁的拥有权）"><a href="#锁池（排队，竞争锁的拥有权）" class="headerlink" title="锁池（排队，竞争锁的拥有权）"></a>锁池（排队，竞争锁的拥有权）</h3><p>假设线程A已经拥有了某个对象的锁，而其他线程B、C想要调用这个对象的某个synchronized方法，由于B、C线程在进入对象的synchronized方法（或者块）之前必须获得该对象锁的拥有权，恰巧该对象的锁目前正在被线程A占用，此时B、C线程就会被阻塞，进入一个地方去等待锁的释放，这个地方便是该对象的锁池</p>
<h3 id="等待池（不参与竞争锁的拥有权，等notify，或wait时间到）"><a href="#等待池（不参与竞争锁的拥有权，等notify，或wait时间到）" class="headerlink" title="等待池（不参与竞争锁的拥有权，等notify，或wait时间到）"></a>等待池（不参与竞争锁的拥有权，等notify，或wait时间到）</h3><p>假设线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁，同时线程A就进入到了该对象的等待池中，进入到等待池中的线程不会去竞争该对象的锁</p>
<ul>
<li>notifyAll会让所有处于等待池的线程全部进入锁池中，去竞争</li>
<li>notify只会随机选取一个处于等待池中的线程，进入到锁池中，去竞争</li>
</ul>
<h2 id="9、如何中断线程"><a href="#9、如何中断线程" class="headerlink" title="9、如何中断线程"></a>9、如何中断线程</h2><h3 id="已经被抛弃的方法"><a href="#已经被抛弃的方法" class="headerlink" title="已经被抛弃的方法"></a>已经被抛弃的方法</h3><ul>
<li>stop方法</li>
<li>suspend和resume方法</li>
</ul>
<h3 id="目前使用的方法"><a href="#目前使用的方法" class="headerlink" title="目前使用的方法"></a>目前使用的方法</h3><ul>
<li>interrupt方法，通知线程应该要中断了<br>-&gt; 如果线程处于被阻塞的状态，那么线程将立即退出被阻塞的状态，并抛出一个InterruptedException异常<br>-&gt; 如果线程处于正常的活动状态，那么会将该线程的中断标志设置为true，被设置中断标志的线程会正常运行，需要手动处理</li>
</ul>
<p>要经常检查中断标志位</p>
<h2 id="10、yield暗示可以让出当前线程的CPU资源"><a href="#10、yield暗示可以让出当前线程的CPU资源" class="headerlink" title="10、yield暗示可以让出当前线程的CPU资源"></a>10、yield暗示可以让出当前线程的CPU资源</h2><p>不会对锁造成影响，调度器可能会忽略，不一定每次都一样</p>

  </div>
</article>
    </div>
    <div class="footer">
    <p>
        © Copyright 2022 <a target="_blank" rel="noopener" href="https://github.com/inferno0303/" style="color: #ccc;">inferno0303</a>
    </p>
</div>
</body>

</html>